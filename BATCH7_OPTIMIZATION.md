# ç¬¬ä¸ƒæ‰¹ä¼˜åŒ–ï¼šLayer 0 æè‡´æ€§èƒ½æ”¹é€ 

## ä¼˜åŒ–èƒŒæ™¯

### æ€§èƒ½ç“¶é¢ˆåˆ†æ
- **å½“å‰çŠ¶æ€**ï¼šGLOVE æœç´¢æ—¶é—´ 17.25ms/query
- **ç“¶é¢ˆå®šä½**ï¼šLayer 0 ç²¾ç¡®æœç´¢é˜¶æ®µå ç”¨ >95% æ—¶é—´
- **æ ¹æœ¬åŸå› **ï¼š
  1. æ¯æ¬¡æŸ¥è¯¢æ‰§è¡Œçº¦ 12,000 æ¬¡è·ç¦»è®¡ç®—
  2. `std::priority_queue` é¢‘ç¹ push/pop æ“ä½œ
  3. éšæœºå†…å­˜è®¿é—®å¯¼è‡´ Cache Miss
  4. é‚»å±…éå†æœªæå‰ç»ˆæ­¢

### ä¼˜åŒ–ç›®æ ‡
å°†æœç´¢æ—¶é—´ä» **17.25ms** å‹ç¼©è‡³ **5ms ä»¥ä¸‹**

---

## ä¼˜åŒ–æ–¹æ¡ˆ

### 1. å›ºå®šæ•°ç»„æ›¿ä»£ä¼˜å…ˆé˜Ÿåˆ—
**é—®é¢˜**ï¼š`std::priority_queue` æ¯æ¬¡ push/pop éœ€è¦å †è°ƒæ•´ï¼Œæ¶‰åŠè™šå‡½æ•°è°ƒç”¨å’Œæ¨¡æ¿å®ä¾‹åŒ–å¼€é”€

**æ–¹æ¡ˆ**ï¼š
```cpp
struct Candidate { float dist; int id; };
Candidate W[512];  // å›ºå®šå¤§å°æ•°ç»„ï¼Œæ ˆä¸Šåˆ†é…
int W_size = 0;
```

**ä¼˜åŠ¿**ï¼š
- æ¶ˆé™¤åŠ¨æ€å†…å­˜åˆ†é…
- L1 ç¼“å­˜å†…è¿ç»­å­˜å‚¨
- ç¼–è¯‘å™¨æ›´å¥½åœ°ä¼˜åŒ–è®¿é—®æ¨¡å¼

**é¢„æœŸæ”¶ç›Š**ï¼šå‡å°‘ 20% å¼€é”€

---

### 2. æ’å…¥æ’åºä¿æŒæœ‰åº
**é—®é¢˜**ï¼šå †æ“ä½œè™½ç„¶æ—¶é—´å¤æ‚åº¦ O(log n)ï¼Œä½†å¯¹å°è§„æ¨¡ ef (200å·¦å³) å¸¸æ•°è¾ƒå¤§

**æ–¹æ¡ˆ**ï¼š
```cpp
// æ’å…¥æ’åºä¿æŒ W æœ‰åº
int insert_pos = min(W_size, ef);
while (insert_pos > 0 && W[insert_pos - 1].dist > d) {
    if (insert_pos < 512) W[insert_pos] = W[insert_pos - 1];
    insert_pos--;
}
if (insert_pos < ef) {
    W[insert_pos] = {d, nid};
    if (W_size < ef) W_size++;
}
```

**ä¼˜åŠ¿**ï¼š
- å°è§„æ¨¡æ•°æ®æ’å…¥æ’åºæ¯”å †æ›´å¿«ï¼ˆCPU åˆ†æ”¯é¢„æµ‹å‹å¥½ï¼‰
- æ•°ç»„è¿ç»­ç§»åŠ¨åˆ©ç”¨ SIMD ä¼˜åŒ–ï¼ˆç¼–è¯‘å™¨è‡ªåŠ¨å‘é‡åŒ–ï¼‰

**é¢„æœŸæ”¶ç›Š**ï¼šé…åˆä¼˜åŒ–1å…±å‡å°‘ 20% å¼€é”€

---

### 3. æµæ°´çº¿é¢„å–
**é—®é¢˜**ï¼šGLOVE å‘é‡åº“ 1.19M Ã— 100ç»´ï¼Œè®¿é—®é‚»å±…å‘é‡å‡ ä¹å…¨æ˜¯ Cache Missï¼ˆçº¦100å‘¨æœŸå»¶è¿Ÿï¼‰

**æ–¹æ¡ˆ**ï¼š
```cpp
for (int i = 0; i < neighbor_count; ++i) {
    int nid = neighbors_ptr[i];
    
    // æå‰ 2 ä¸ªé‚»å±…é¢„å–å‘é‡æ•°æ®
    if (i + 2 < neighbor_count) {
        _mm_prefetch((const char*)&vectors[neighbors_ptr[i+2] * dimension], 
                     _MM_HINT_T0);
    }
    
    float d = distance(query, &vectors[nid * dimension], dimension);
    // ...
}
```

**ä¼˜åŠ¿**ï¼š
- éšè— DRAM è®¿å­˜å»¶è¿Ÿ
- CPU åœ¨ç­‰å¾…å†…å­˜æ—¶å¯æ‰§è¡Œåç»­æŒ‡ä»¤
- æå‰ 2 ä¸ªé‚»å±…æ˜¯ç»éªŒæœ€ä¼˜å€¼ï¼ˆå¤ªè¿œé¢„å–å¤±æ•ˆï¼Œå¤ªè¿‘æ¥ä¸åŠåŠ è½½ï¼‰

**é¢„æœŸæ”¶ç›Š**ï¼šå‡å°‘ 35% å†…å­˜å»¶è¿Ÿå¼€é”€

---

### 4. è´ªå©ªæŒ‡é’ˆå›æº¯
**é—®é¢˜**ï¼šä¼ ç»Ÿ HNSW æŒ‰è·ç¦»æ’åºé¡ºåºæ¢ç´¢ï¼Œå¯èƒ½é”™è¿‡æ›´è¿‘çš„å€™é€‰

**æ–¹æ¡ˆ**ï¼š
```cpp
int curr_pos = 0;
while (curr_pos < W_size && curr_pos < ef) {
    Candidate current = W[curr_pos++];
    
    for (int i = 0; i < neighbor_count; ++i) {
        // ... è®¡ç®—è·ç¦»å¹¶æ’å…¥ ...
        
        // å¦‚æœæ’å…¥ä½ç½®æ¯”å½“å‰å¤„ç†ä½ç½®æ›´è¿‘ï¼Œå›æº¯
        if (insert_pos < curr_pos) 
            curr_pos = insert_pos;
    }
}
```

**ä¼˜åŠ¿**ï¼š
- å¿«é€Ÿæ”¶æ•›åˆ°å±€éƒ¨æœ€ä¼˜
- åç»­è¿œè·ç¦»å€™é€‰è¢«æå‰ç»ˆæ­¢å‰ªæè¿‡æ»¤
- å‡å°‘æ— æ•ˆå€™é€‰æ¢ç´¢

**é¢„æœŸæ”¶ç›Š**ï¼šå‡å°‘ 15% æœç´¢è·¯å¾„

---

### 5. æå‰ç»ˆæ­¢å‰ªæ
**é—®é¢˜**ï¼šå³ä½¿å€™é€‰é›†å·²æ»¡ä¸”å½“å‰ç‚¹å¾ˆè¿œï¼Œä»ä¼šå®Œæ•´éå†å…¶é‚»å±…

**æ–¹æ¡ˆ**ï¼š
```cpp
if (W_size >= ef && current.dist > W[ef-1].dist * 1.05f)
    break;
```

**ä¼˜åŠ¿**ï¼š
- é˜ˆå€¼ 1.05x å¹³è¡¡å¬å›ç‡ä¸é€Ÿåº¦
- é¿å…æ¢ç´¢æ˜æ˜¾æ— ç”¨çš„è¿œè·ç¦»å€™é€‰
- å‡å°‘è·ç¦»è®¡ç®—æ¬¡æ•°

**é¢„æœŸæ”¶ç›Š**ï¼šå‡å°‘ 10% æ— æ•ˆè®¡ç®—

---

## å®ç°ç»†èŠ‚

### ä»£ç ç»“æ„
```cpp
vector<int> Solution::search_layer(const float *query, 
                                   const vector<int> &entry_points,
                                   int ef, int level) const
{
    tls_visited.resize(num_vectors);
    int tag = tls_visited.get_new_tag();
    auto &visited = tls_visited.visited;

    // === Layer 0 æè‡´æ€§èƒ½è·¯å¾„ ===
    if (level == 0 && !final_graph_flat.empty())
    {
        // 1. å›ºå®šæ•°ç»„å€™é€‰æ± 
        struct Candidate { float dist; int id; };
        Candidate W[512];
        int W_size = 0;
        
        // åˆå§‹åŒ–å¹¶æ’åº
        for (int ep : entry_points) {
            if (visited[ep] != tag) {
                visited[ep] = tag;
                float d = distance(query, &vectors[ep * dimension], dimension);
                W[W_size++] = {d, ep};
            }
        }
        sort(W, W + W_size, [](const Candidate &a, const Candidate &b) {
            return a.dist < b.dist;
        });
        
        int curr_pos = 0;
        
        // 2. è´ªå©ªæœç´¢ + æå‰ç»ˆæ­¢
        while (curr_pos < W_size && curr_pos < ef)
        {
            Candidate current = W[curr_pos++];
            
            // 5. æå‰ç»ˆæ­¢å‰ªæ
            if (W_size >= ef && current.dist > W[ef-1].dist * 1.05f)
                break;
            
            // è®¿é—®æ‰å¹³åŒ–é‚»å±…
            int max_neighbors_l0 = 2 * M;
            long long offset = (long long)current.id * (max_neighbors_l0 + 1);
            int neighbor_count = final_graph_flat[offset];
            const int *neighbors_ptr = &final_graph_flat[offset + 1];
            
            for (int i = 0; i < neighbor_count; ++i)
            {
                int nid = neighbors_ptr[i];
                
                // 3. æµæ°´çº¿é¢„å–
                if (i + 2 < neighbor_count) {
                    _mm_prefetch((const char*)&vectors[neighbors_ptr[i+2] * dimension], 
                                 _MM_HINT_T0);
                }
                
                if (visited[nid] != tag)
                {
                    visited[nid] = tag;
                    float d = distance(query, &vectors[nid * dimension], dimension);
                    
                    if (W_size < ef || d < W[min(W_size, ef)-1].dist)
                    {
                        // 2. æ’å…¥æ’åº
                        int insert_pos = min(W_size, ef);
                        while (insert_pos > 0 && W[insert_pos - 1].dist > d) {
                            if (insert_pos < 512)
                                W[insert_pos] = W[insert_pos - 1];
                            insert_pos--;
                        }
                        
                        if (insert_pos < ef) {
                            W[insert_pos] = {d, nid};
                            if (W_size < ef) W_size++;
                            
                            // 4. è´ªå©ªæŒ‡é’ˆå›æº¯
                            if (insert_pos < curr_pos)
                                curr_pos = insert_pos;
                        }
                    }
                }
            }
        }
        
        // è¿”å› Top ef å€™é€‰
        vector<int> result;
        result.reserve(min(W_size, ef));
        for (int i = 0; i < min(W_size, ef); ++i)
            result.push_back(W[i].id);
        return result;
    }

    // === é Layer 0 ä¿æŒåŸæœ‰ä¼˜å…ˆé˜Ÿåˆ—é€»è¾‘ ===
    // ...ï¼ˆé«˜å±‚èŠ‚ç‚¹å°‘ï¼Œä¼˜å…ˆé˜Ÿåˆ—è¶³å¤Ÿé«˜æ•ˆï¼‰
}
```

### å…³é”®å‚æ•°
- **å›ºå®šæ•°ç»„å¤§å°**ï¼š512ï¼ˆè¿œå¤§äº ef_search=200ï¼‰
- **é¢„å–è·ç¦»**ï¼šæå‰ 2 ä¸ªé‚»å±…
- **ç»ˆæ­¢é˜ˆå€¼**ï¼š1.05xï¼ˆ5% å®¹é”™ï¼‰
- **å›æº¯ç­–ç•¥**ï¼šç«‹å³å›åˆ°æ’å…¥ä½ç½®

---

## æ€§èƒ½é¢„æœŸ

### ç†è®ºåˆ†æ
| ä¼˜åŒ–æŠ€æœ¯ | è€—æ—¶ç¼©å‡ | åŸç† |
|---------|---------|------|
| å›ºå®šæ•°ç»„ + æ’å…¥æ’åº | 20% | æ¶ˆé™¤å †æ“ä½œå’ŒåŠ¨æ€å†…å­˜åˆ†é… |
| æµæ°´çº¿é¢„å– | 35% | éšè— 100 å‘¨æœŸ DRAM å»¶è¿Ÿ |
| è´ªå©ªæŒ‡é’ˆå›æº¯ | 15% | å¿«é€Ÿæ”¶æ•›åˆ°å±€éƒ¨æœ€ä¼˜ |
| æå‰ç»ˆæ­¢å‰ªæ | 10% | è¿‡æ»¤è¿œè·ç¦»æ— æ•ˆå€™é€‰ |

**ç´¯è®¡é¢„æœŸ**ï¼š
- åŸæœç´¢æ—¶é—´ï¼š17.25ms
- é¢„æœŸä¼˜åŒ–åï¼š17.25ms Ã— (1 - 20% - 35% - 15% - 10%) = **17.25ms Ã— 0.20 = 3.45ms**
- è€ƒè™‘ç›¸äº’å½±å“ï¼Œå®é™…é¢„æœŸï¼š**4-7ms**

### å®æµ‹ç›®æ ‡
- âœ… æ„å»ºæ—¶é—´ï¼š< 2000sï¼ˆå·²è¾¾æ ‡ 347sï¼‰
- âœ… å¬å›ç‡@10ï¼šâ‰¥ 97%ï¼ˆå·²è¾¾æ ‡ 97.7%ï¼‰
- ğŸ¯ æœç´¢æ—¶é—´ï¼š< 5msï¼ˆå¾…éªŒè¯ï¼Œå½“å‰ 17.25msï¼‰

---

## é£é™©è¯„ä¼°

### æ½œåœ¨é—®é¢˜
1. **å¬å›ç‡ä¸‹é™**
   - **é£é™©ç‚¹**ï¼šæå‰ç»ˆæ­¢é˜ˆå€¼ 1.05x å¯èƒ½è¿‡æ»¤æ‰çœŸå®è¿‘é‚»
   - **ç¼“è§£æªæ–½**ï¼šå…ˆæµ‹è¯• 1.1xï¼Œé€æ­¥é™ä½è‡³ 1.05x
   - **éªŒè¯æ–¹æ³•**ï¼šå¯¹æ¯”ä¼˜åŒ–å‰åå¬å›ç‡

2. **è¾¹ç•Œæ¡ä»¶**
   - **é£é™©ç‚¹**ï¼šef_search è¶…è¿‡ 512
   - **ç¼“è§£æªæ–½**ï¼šæ–­è¨€æ£€æŸ¥ `assert(ef <= 512)`
   - **å½“å‰çŠ¶æ€**ï¼šef_search=200ï¼Œå®‰å…¨è¾¹ç•Œè¶³å¤Ÿ

3. **å¹¶å‘å®‰å…¨**
   - **é£é™©ç‚¹**ï¼šå›ºå®šæ•°ç»„åœ¨å¤šçº¿ç¨‹ä¸‹æ˜¯å¦å®‰å…¨
   - **ç¼“è§£æªæ–½**ï¼šä»ä½¿ç”¨ thread_local visitedï¼Œæ¯çº¿ç¨‹ç‹¬ç«‹ W æ•°ç»„ï¼ˆæ ˆåˆ†é…ï¼‰
   - **å½“å‰çŠ¶æ€**ï¼šâœ“ çº¿ç¨‹å®‰å…¨ï¼ˆæ ˆå˜é‡å¤©ç„¶çº¿ç¨‹ç‹¬ç«‹ï¼‰

### å›é€€æ–¹æ¡ˆ
å¦‚æœä¼˜åŒ–å¤±è´¥ï¼ˆå¬å›ç‡<97% æˆ–ç¨‹åºå´©æºƒï¼‰ï¼Œé€šè¿‡ä»¥ä¸‹æ–¹å¼å›é€€ï¼š

```bash
git checkout HEAD~1 MySolution.cpp
g++ -std=c++11 -O3 -mavx2 -mfma -march=native -fopenmp test_solution.cpp MySolution.cpp -o test_solution.exe
```

---

## è¿›ä¸€æ­¥ä¼˜åŒ–ç©ºé—´ï¼ˆå¦‚æœªè¾¾æ ‡ï¼‰

### 1. SIMD ç»´åº¦ç¡¬ç¼–ç 
**å½“å‰**ï¼šdistance() å‡½æ•°ä½¿ç”¨å¾ªç¯å¤„ç† 100 ç»´
**ä¼˜åŒ–**ï¼šå±•å¼€ä¸º 96 (12Ã—8 AVX2) + 4 (æ ‡é‡)
```cpp
// é’ˆå¯¹ GLOVE 100 ç»´ç¡¬ç¼–ç 
float distance_glove100(const float *a, const float *b) {
    __m256 sum1 = _mm256_setzero_ps();
    __m256 sum2 = _mm256_setzero_ps();
    
    // å¤„ç† 96 ç»´ (12 æ¬¡ AVX2ï¼Œæ¯æ¬¡ 8 ä¸ª float)
    for (int i = 0; i < 12; ++i) {
        __m256 va = _mm256_loadu_ps(a + i*8);
        __m256 vb = _mm256_loadu_ps(b + i*8);
        __m256 diff = _mm256_sub_ps(va, vb);
        sum1 = _mm256_fmadd_ps(diff, diff, sum1);
    }
    
    // å¤„ç†å‰©ä½™ 4 ç»´
    for (int i = 96; i < 100; ++i) {
        float diff = a[i] - b[i];
        sum2[0] += diff * diff;
    }
    
    return _mm256_reduce_add_ps(sum1) + sum2[0];
}
```
**é¢„æœŸæ”¶ç›Š**ï¼š5-10% è·ç¦»è®¡ç®—åŠ é€Ÿ

### 2. åŸå­è®¡æ•°å™¨æ‰¹é‡åŒ–
**å½“å‰**ï¼šæ¯æ¬¡ distance() è°ƒç”¨éƒ½ `distance_computations++`
**ä¼˜åŒ–**ï¼šæŸ¥è¯¢å†…éƒ¨ç´¯åŠ ï¼Œç»“æŸæ—¶ä¸€æ¬¡æ€§æ›´æ–°
```cpp
long long local_count = 0;
for (...) {
    distance(...);
    local_count++;
}
distance_computations.fetch_add(local_count, std::memory_order_relaxed);
```
**é¢„æœŸæ”¶ç›Š**ï¼š1-2% åŸå­æ“ä½œå¼€é”€

### 3. åŠ¨æ€ ef_search
**å½“å‰**ï¼šå›ºå®š ef_search=200
**ä¼˜åŒ–**ï¼šæ ¹æ®å…¥å£ç‚¹è·ç¦»è°ƒæ•´
```cpp
float entry_dist = distance(query, &vectors[entry_point * dimension], dimension);
int dynamic_ef = (entry_dist < threshold) ? ef_search / 2 : ef_search;
```
**é¢„æœŸæ”¶ç›Š**ï¼š10-20% æœç´¢èŒƒå›´ç¼©å‡

---

## å®æ–½çŠ¶æ€

### âœ… å·²å®Œæˆ
- [x] ä»£ç å®ç°ï¼ˆMySolution.cpp 153-260è¡Œï¼‰
- [x] ç¼–è¯‘éªŒè¯ï¼ˆæ— é”™è¯¯ï¼Œä»…è­¦å‘Šï¼‰
- [x] æ–‡æ¡£æ›´æ–°ï¼ˆAGENT.mdï¼‰

### ğŸ”„ è¿›è¡Œä¸­
- [ ] GLOVE å®Œæ•´æµ‹è¯•ï¼ˆé¢„è®¡5åˆ†é’Ÿï¼‰
- [ ] æ€§èƒ½æŒ‡æ ‡éªŒè¯ï¼ˆæœç´¢æ—¶é—´ < 5msï¼‰
- [ ] å¬å›ç‡ç¨³å®šæ€§æ£€æŸ¥ï¼ˆâ‰¥ 97%ï¼‰

### ğŸ“‹ å¾…æ‰§è¡Œï¼ˆå¦‚éœ€è¦ï¼‰
- [ ] è°ƒæ•´ç»ˆæ­¢é˜ˆå€¼ï¼ˆ1.05x â†’ 1.1xï¼‰
- [ ] SIMD ç»´åº¦ç¡¬ç¼–ç 
- [ ] åŸå­è®¡æ•°å™¨æ‰¹é‡åŒ–

---

## æµ‹è¯•éªŒè¯

### æµ‹è¯•å‘½ä»¤
```bash
# å¿«é€Ÿæµ‹è¯•
test_batch7.bat

# æ‰‹åŠ¨æµ‹è¯•
g++ -std=c++11 -O3 -mavx2 -mfma -march=native -fopenmp test_solution.cpp MySolution.cpp -o test_solution.exe
set OMP_NUM_THREADS=8
test_solution.exe ..\data_o\data_o\glove
```

### éªŒæ”¶æ ‡å‡†
| æŒ‡æ ‡ | ç¬¬å…­æ‰¹ï¼ˆåŸºçº¿ï¼‰ | ç¬¬ä¸ƒæ‰¹ï¼ˆç›®æ ‡ï¼‰ | çŠ¶æ€ |
|------|---------------|---------------|------|
| æ„å»ºæ—¶é—´ | 347s | < 2000s | âœ“ |
| å¬å›ç‡@10 | 97.7% | â‰¥ 97.0% | å¾…æµ‹ |
| æœç´¢æ—¶é—´ | 17.25ms | < 5ms | å¾…æµ‹ |
| è·ç¦»è®¡ç®— | 12,000/query | < 15,000/query | å¾…æµ‹ |

---

## æ€»ç»“

ç¬¬ä¸ƒæ‰¹ä¼˜åŒ–é€šè¿‡**å½»åº•é‡æ„ Layer 0 æœç´¢è·¯å¾„**ï¼Œé‡‡ç”¨å›ºå®šæ•°ç»„ã€æ’å…¥æ’åºã€æµæ°´çº¿é¢„å–ã€è´ªå©ªå›æº¯å’Œæå‰ç»ˆæ­¢äº”å¤§æŠ€æœ¯ï¼Œé¢„æœŸå°†æœç´¢æ—¶é—´ä» 17.25ms å‹ç¼©è‡³ **4-7ms**ï¼Œè¾¾åˆ° 5ms ä»¥ä¸‹çš„æè‡´æ€§èƒ½ç›®æ ‡ã€‚

ä¼˜åŒ–æ ¸å¿ƒæ€æƒ³ï¼š**ç”¨ç©ºé—´æ¢æ—¶é—´ï¼Œç”¨ç®€å•æ¢å¤æ‚ï¼Œç”¨ç¡®å®šæ€§æ¢çµæ´»æ€§**â€”â€”é’ˆå¯¹ Layer 0 çš„ç‰¹å®šåœºæ™¯ï¼ˆèŠ‚ç‚¹å¤šã€é‚»å±…å¯†é›†ã€æŸ¥è¯¢é¢‘ç¹ï¼‰ï¼Œæ”¾å¼ƒé€šç”¨æ•°æ®ç»“æ„ï¼ˆpriority_queueï¼‰ï¼Œé‡‡ç”¨æè‡´ä¼˜åŒ–çš„å›ºå®šæ•°ç»„æ–¹æ¡ˆï¼Œæ¢å–æ•°å€æ€§èƒ½æå‡ã€‚
